# -*- coding: utf-8 -*-
"""Part4 (1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1d_QF9IfeL0bdRqaziB5DYn0RtniYd3lM
"""

import cv2
import numpy as np
from scipy.optimize import curve_fit
import matplotlib.pyplot as plt
from keras.models import Sequential
from keras.layers import Dense
from sklearn.model_selection import train_test_split

# Load the image
image = cv2.imread('red_line_image.jpg')

# Convert image to HSV color space
hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)

# Define lower and upper thresholds for red color in HSV
lower_red1 = np.array([0, 50, 50])
upper_red1 = np.array([10, 255, 255])
lower_red2 = np.array([170, 50, 50])
upper_red2 = np.array([180, 255, 255])

# Create masks for red pixels using the thresholds
red_mask1 = cv2.inRange(hsv_image, lower_red1, upper_red1)
red_mask2 = cv2.inRange(hsv_image, lower_red2, upper_red2)
red_mask = cv2.bitwise_or(red_mask1, red_mask2)

# Apply Canny edge detection on the red mask
edges = cv2.Canny(red_mask, 50, 150, apertureSize=3)

# Find contours in the edge image
contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Check if contours were found
if contours:
    # Extract the largest contour (assuming it corresponds to the red line)
    largest_contour = max(contours, key=cv2.contourArea)

    # Extract the coordinates of the red line
    x_coords = largest_contour[:, 0, 0]
    y_coords = largest_contour[:, 0, 1]

    # Print the coordinates of the red dots
    for x, y in zip(x_coords, y_coords):
        print(f"Red dot coordinates: ({x}, {y})")

    # Fit a polynomial curve to the coordinates
    degree = 3  # Degree of the polynomial curve
    coeffs = np.polyfit(x_coords, y_coords, degree)
    poly_func = np.poly1d(coeffs)

    # Generate x values for plotting the curve
    x_plot = np.linspace(min(x_coords), max(x_coords), 100)

    # Evaluate the polynomial function for the plotted x values
    y_plot = poly_func(x_plot)

    # Plot the original image with the detected red line and the fitted curve
    plt.figure(figsize=(8, 6))
    plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
    plt.plot(x_coords, y_coords, 'ro', label='Detected Red Line')
    # plt.plot(x_plot, y_plot, 'b-', label='Fitted Curve')
    plt.xlabel('x')
    plt.ylabel('y')
    plt.title('Fitting a Function to the Detected Red Line')
    plt.legend()
    plt.show()
else:
    print("No red line detected.")

model = Sequential()
model.add(Dense(16, input_dim=1, activation='relu'))  # Increase the number of neurons in the hidden layer
model.add(Dense(8, activation='relu'))  # Add an additional hidden layer
model.add(Dense(1))
model.compile(loss='mean_squared_error', optimizer='adam')

# Split the coordinates into training and test data
x_train, x_test, y_train, y_test = train_test_split(x_coords, y_coords, test_size=0.25, random_state=42)

# Convert the 1D arrays to 2D arrays for compatibility with the model
x_train = np.reshape(x_train, (-1, 1))
y_train = np.reshape(y_train, (-1, 1))
x_test = np.reshape(x_test, (-1, 1))
y_test = np.reshape(y_test, (-1, 1))

# Train the model
history = model.fit(x_train, y_train, epochs=100, batch_size=32, verbose=0)

# Make predictions
predictions = model.predict(x_test)

# Sort the test data points based on x_test
sorted_indices = np.argsort(x_test.flatten())
x_test_sorted = x_test[sorted_indices]
y_test_sorted = y_test[sorted_indices]

# Plot the results
plt.figure(figsize=(8, 6))
plt.scatter(x_test_sorted, y_test_sorted, color='blue', label='Actual')
plt.plot(x_test_sorted, predictions, color='red', label='Predicted')
plt.xlabel('x')
plt.ylabel('y')
plt.title('Approximation of Sine Function')
plt.legend()
plt.show()